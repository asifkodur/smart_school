#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
# generated by wxGlade 0.6.8 on Fri Sep 22 20:57:22 2017
#

import wx,wx.animate
from threading import Thread
from wx.lib.pubsub import Publisher
import gettext
from dboperations import db_operations
import requests
import subprocess
from BeautifulSoup import BeautifulSoup
import os,sys
from distutils.version import  StrictVersion
from subprocess import Popen,PIPE,STDOUT



#https://github.com/asifkodur/smartschool/releases/download/v2.0.0/smart_school.tar.gz
download_url="https://github.com/asifkodur/smartschool/archive/"


class software_update():
    
    def __init__(self):
        
        
        self.session_request = requests.session()
        self.binary_download_link=""
        self.source_tar_download_link=''
        self.source_zip_download_link=''
        self.latest_version=''
        self.file_save_location="/tmp/smart_school"
        
        self.get_latest_version()
        
    def load_download_links(self):# Finds 3 downoad links of latest release-of the binary,source.zip and source.tar.gz
        
        url="https://github.com/asifkodur/smartschool/releases/latest" # the url gets redirected to the latest release
    
        try:
            
            result = self.session_request.get(url,timeout=10)
        except:
            return [False, "Cannot access web page"]
        
        content=str(result.content)
        soup = BeautifulSoup(content)
        for link in soup.findAll('a'):
            if str(link.get('href')).find('smartschool/releases/download')!=-1:
                self.binary_download_link= "https://github.com"+link.get('href')
            elif str(link.get('href')).find('smartschool/archive')!=-1:
                #print "%%",link.get('href')
                if str(link.get('href')).find('zip')!=-1:
                    self.source_zip_download_link= "https://github.com"+link.get('href')
                    #print self.source_zip_download_link
                else:
                    self.source_tar_download_link="https://github.com"+link.get('href')
            


        return True
    def get_latest_version(self):
        url="https://github.com/asifkodur/smartschool/releases/latest"
        try:
            result = self.session_request.get(url,timeout=10)

            
        except:
            return [False,"Cannot access github page for retrieving latest release details"]
            
        self.latest_version=result.url.split('/').pop()

        return self.latest_version

    def download(self,download_link):
        if  not os.path.exists(self.file_save_location):
            os.mkdir(self.file_save_location)
        file_name = self.file_save_location+"/"+download_link.split('/').pop()
        result= requests.get(download_link, stream=True)
        file_size = int(result.headers['Content-Length'])
        
        return result,file_name,file_size
        
    def get_download_link_source_zip(self):
        if self.source_zip_download_link=='':
            self.load_download_links()
        return self.source_zip_download_link
    
    def get_download_link_source_tar(self):
        
        if self.source_tar_download_link=="":
            self.load_download_links()
        return self.source_tar_download_link
    
    def get_binary_download_link(self):
        if self.binary_download_link=='':
            self.load_download_links()
        
        return self.binary_download_link
    
    def get_current_installed_version(self):
        
        dir = os.path.split(sys.argv[0])[0]
        version_file_path=dir+"/current_version"
        with open(version_file_path, 'r') as f:
            return f.readline()
            
        
    def is_update_available(self):
        latest=self.get_latest_version()
        current=str(self.get_current_installed_version())
        
        if StrictVersion(latest)>StrictVersion(current):
            return True
        else:
            return False
            
    def backup_db(self,DB): # DB is passed as sqlite rejects connection frm another thread 
        import getpass
        
        
        dir = os.path.split(sys.argv[0])[0]
        
        username=getpass.getuser()
        home="/home/"+username
        os.chdir(home)
        if not os.path.exists(".smart_school"):
            
        
        
            os.mkdir(".smart_school")    
            os.chdir(".smart_school")
            os.mkdir("backup")
            
                    
        elif not os.path.exists(".smart_school/backup"):
            
            os.chdir(".smart_school")
            os.mkdir("backup")
            
        
            
        
        DB.export(home+"/.smart_school/backup/database")
            
        

    def install(self,DB):
        import stat
        self.backup_db(DB)
        '''output=Popen(['gksudo','rmdir','/var/21'],stdout=PIPE,stderr=PIPE)
        output = p.stdout.read()
        print output
        '''
        
        #print subprocess.check_call('cd /tmp/smart_school', shell=True)# IF OUT PUT 0 success, if 1, fail, 3 password error
        #print subprocess.call('gksu chmod +x /tmp/smart_school/install.sh',shell=True,stderr=subprocess.STDOUT)# IF OUT PUT 0 success, if 1, fail, 3 password error
        os.chmod('/tmp/smart_school/install.sh', stat.S_IEXEC)
        output=subprocess.call('cd /tmp/smart_school\ngksu ./install.sh',shell=True)#,stderr=subprocess.STDOUT)# IF OUT PUT 0 success, if 1, fail, 3 password error
        return output # success if out put is 0
    def extract(self):
        import tarfile
        results=[]
        results += [each for each in os.listdir(self.file_save_location) if each.endswith('.gz')]
        
        #if extraxted already overwrite error
        for each in results:
            
            
            tar = tarfile.open(self.file_save_location+"/"+each,'r:gz')
            
            for one_member in  tar.getnames():# Deleting extracted files if any
                try:os.remove(self.file_save_location+"/"+one_member)
                except:pass

            tar.extractall(path=self.file_save_location)
            tar.close()
            
    def import_db(self,DB):
        import getpass
        
        dir = os.path.split(sys.argv[0])[0]
        
        username=getpass.getuser()
        path="/home/"+username+"/.smart_school/backup/database"
          
        DB.import_(path)
        






class update_thread(Thread):
    
    
    def __init__(self,check=True,install=False):
        """Init Worker Thread Class."""
        Thread.__init__(self)
        
        self.SU=software_update()
        self.check_only=check  # True if need to run functions to check for installation
        self.install_only=install
        self.stopped=False
        
        self.start()    # start the thread
 
    
    def stop(self):
        self.stopped=True

    def stopped(self):
        return self.stopped
    def check_for_updates(self):
        wx.CallAfter(Publisher().sendMessage, "update","Checking for Updates")
        if self.stopped:
            wx.CallAfter(Publisher().sendMessage, "update","Aborted")
            return 0
        # This is the code executed in the new thread.
        
        self.installed_version=self.SU.get_current_installed_version()
        try:
            self.latest_version=self.SU.get_latest_version()
            wx.CallAfter(Publisher().sendMessage, "update_versions",(self.installed_version,self.latest_version))
        except:
            wx.CallAfter(Publisher().sendMessage, "error_report","Could not fetch latest version details")
            self.latest_version=None
            
        wx.CallAfter(Publisher().sendMessage, "update_versions",(self.installed_version, self.latest_version))
        
        wx.CallAfter(Publisher().sendMessage, "update","Checking for Updates")
        if self.stopped:
            wx.CallAfter(Publisher().sendMessage, "update","Aborted")
            return 0
        try:
            if not self.SU.is_update_available(): # True if new version available
                wx.CallAfter(Publisher().sendMessage, "update","Software is Uptodate")
                return 0
            
        except:
            wx.CallAfter(Publisher().sendMessage, "error_report","Failed to check for updates..try again later")
            return 0
        
        return True
    
    def download_updates(self):
        if self.stopped:
            wx.CallAfter(Publisher().sendMessage, "update","Aborted")
            return 0
        wx.CallAfter(Publisher().sendMessage, "update","Trying to fetch dowload link.....")
        try:
            
            link1=self.SU.get_binary_download_link()
            wx.CallAfter(Publisher().sendMessage, "update","Link fetched")
        except:
            wx.CallAfter(Publisher().sendMessage, "error_report","Failed to fetch download link")
            return 
        try:
            wx.CallAfter(Publisher().sendMessage, "stop_animation","dowloading updates")
            wx.CallAfter(Publisher().sendMessage, "update","dowloading updates......")
            result,file_name,file_size=self.SU.download(link1)
            
            chunk = 1
            num_bars = file_size
            i_repeat=file_size/100
            progress_perc=0
            i=0# shows progresss in 100
            with open(file_name, 'wb') as f:
                for chunk in result.iter_content():
                    f.write(chunk)
                    i+=1
                    if i>=i_repeat:
                        progress_perc+=1
                        
                        wx.CallAfter(Publisher().sendMessage, "progress_bar",progress_perc)
                        i=0
                f.close()
                
        except:
            wx.CallAfter(Publisher().sendMessage, "error_report","Failed to download updates")
            return 
        return True
               
    def backup(self):
        if self.stopped:
            wx.CallAfter(Publisher().sendMessage, "update","Aborted")
            return 0
        try:
            wx.CallAfter(Publisher().sendMessage, "update","Backing up database automatically")
            self.SU.backup_db(self.DB)
            wx.CallAfter(Publisher().sendMessage, "update","Backing up success")
        except:
            
            wx.CallAfter(Publisher().sendMessage, "error_report","Backup failed")
            return 0
        return True
    
    def extract(self):
        if self.stopped:
            wx.CallAfter(Publisher().sendMessage, "update","Aborted")
            return 0
        try:
            wx.CallAfter(Publisher().sendMessage, "update","Extracting downloaded archives")
            self.SU.extract()
            wx.CallAfter(Publisher().sendMessage, "update","Extraction completed")
        except:
            
            wx.CallAfter(Publisher().sendMessage, "error_report","Extraction failed")
            return 0
        return True
        
    def install_updates(self):
        if self.stopped:
            wx.CallAfter(Publisher().sendMessage, "update","Aborted")
            return 0
        try:
            wx.CallAfter(Publisher().sendMessage, "update","Installing updates....")
            if self.SU.install(self.DB)==0: #successful if return value 0
                wx.CallAfter(Publisher().sendMessage, "update","Installation completed")
            else:
                wx.CallAfter(Publisher().sendMessage, "error_report","Error in installation process")
                return 0
        except:
            
            wx.CallAfter(Publisher().sendMessage, "error_report","Installation failed")
            return 0
        return True
    
    def import_db(self):
        
        # No abort signal is listened to here
        try:
            wx.CallAfter(Publisher().sendMessage, "update","Updating with backed-up data.....")
            self.SU.import_db(self.DB)
            wx.CallAfter(Publisher().sendMessage, "update","Backup updation completed")
        except:
            
            wx.CallAfter(Publisher().sendMessage, "error_report","Could not restore backed-up data.You may manually import the database")
            return 0
        return True
        

        
    def run(self):
        
        """Run Worker Thread."""
        self.DB=db_operations()
        
        wx.CallAfter(Publisher().sendMessage, "play_animation",True)
        if self.check_only:
            
            if not self.check_for_updates():
                wx.CallAfter(Publisher().sendMessage, "is_update",False)
                wx.CallAfter(Publisher().sendMessage, "stop_animation",True)
                
                return
            else:
                wx.CallAfter(Publisher().sendMessage, "stop_animation",True)
                
                
                wx.CallAfter(Publisher().sendMessage, "update","Checking completed")
                wx.CallAfter(Publisher().sendMessage, "is_update",True)
                
                
                
                
            
        else:
        
            if not self.download_updates():
                return
            if not self.extract():
                return
            if not self.backup():
                return
            if not self.install_updates():
                return
            if not self.import_db():
                return 
            
            wx.CallAfter(Publisher().sendMessage, "update","Successfully updated")
            wx.CallAfter(Publisher().sendMessage, "updation_successful",'')
            wx.CallAfter(Publisher().sendMessage, "update","RESTARTING APP IN 3 SECONDS")
                
    



class update_win(wx.Dialog):
    def __init__(self, *args, **kwds):
        # begin wxGlade: update_win.__init__
        kwds["style"] = wx.DEFAULT_DIALOG_STYLE
        wx.Dialog.__init__(self, *args, **kwds)
        self.label_installed_version = wx.StaticText(self, wx.ID_ANY, ("Installed Version:"))
        self.label_latest_version = wx.StaticText(self, wx.ID_ANY, ("Latest Version"))
        self.label_is_update = wx.StaticText(self, wx.ID_ANY, ("If Update available"))
        self.progress_bar = wx.Gauge(self, wx.ID_ANY, range=100)
        self.animation_panel = wx.Panel(self, wx.ID_ANY)
        self.label_status = wx.StaticText(self, wx.ID_ANY, (""))
        self.button_close = wx.Button(self, wx.ID_ANY, ("Cancel"))
        self.button_install = wx.Button(self, wx.ID_ANY, ("Check for Update"))

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_BUTTON, self.on_cancel, self.button_close)
        self.Bind(wx.EVT_BUTTON, self.on_install, self.button_install)
        self.Bind(wx.EVT_CLOSE, self.on_close)

        
        self.animation_panel.gif = None
        
        
        # create a pubsub receiver
        Publisher().subscribe(self.update, "update")
        Publisher().subscribe(self.error_report, "error_report")
        Publisher().subscribe(self.update_progress_bar, "progress_bar")
        Publisher().subscribe(self.get_versions, "update_versions")
        Publisher().subscribe(self.is_update, "is_update")
        Publisher().subscribe(self.play_animation, "play_animation")
        Publisher().subscribe(self.stop_animation, "stop_animation")
        Publisher().subscribe(self.updation_successful, "updation_successful")
        
        #self.play_animation('')
        #wx.FutureCall(10, self.start_thread)
        

        
        # end wxGlade

    def __set_properties(self):
        # begin wxGlade: update_win.__set_properties
        self.SetTitle(("Software Update"))
        self.SetSize((620, 447))
        #self.button_install.Enable(False)
        self.label_installed_version.SetFont(wx.Font(12, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, ""))
        self.label_latest_version.SetFont(wx.Font(12, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, ""))
        self.label_is_update.SetFont(wx.Font(12, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, ""))
        self.label_status.SetFont(wx.Font(12, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, ""))
        self.button_close.SetMinSize((140, 40))
        self.button_install.SetMinSize((140, 40))
        self.progress_bar.SetMinSize((300,30))
        self.progress_bar.Hide()
        # end wxGlade

    def __do_layout(self):
        sizer_1 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_2 = wx.BoxSizer(wx.VERTICAL)
        sizer_4 = wx.BoxSizer(wx.VERTICAL)
        grid_sizer_3 = wx.GridSizer(1, 2, 20, 20)
        sizer_3 = wx.BoxSizer(wx.HORIZONTAL)
        grid_sizer_1 = wx.GridSizer(3, 1, 0, 0)
        grid_sizer_2 = wx.GridSizer(3, 1, 0, 0)
        grid_sizer_2.Add(self.label_installed_version, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        grid_sizer_2.Add(self.label_latest_version, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        grid_sizer_2.Add(self.label_is_update, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_3.Add(grid_sizer_2, 1, wx.EXPAND, 0)
        grid_sizer_1.Add(self.progress_bar, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        grid_sizer_1.Add(self.animation_panel, 1, wx.ALIGN_CENTER_VERTICAL, 0)
        grid_sizer_1.Add(self.label_status, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_3.Add(grid_sizer_1, 1, wx.EXPAND, 0)
        sizer_2.Add(sizer_3, 3, wx.EXPAND, 0)
        grid_sizer_3.Add(self.button_close, 0, wx.ALIGN_RIGHT | wx.ALIGN_CENTER_VERTICAL, 0)
        grid_sizer_3.Add(self.button_install, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_4.Add(grid_sizer_3, 1, wx.EXPAND, 0)
        sizer_2.Add(sizer_4, 2, wx.EXPAND, 0)
        sizer_1.Add(sizer_2, 1, wx.ALL | wx.EXPAND, 10)
        self.SetSizer(sizer_1)
        self.Layout()
        # end wxGlade

    def on_cancel(self, event):  # wxGlade: update_win.<event_handler>
        try:
            self.thread.stopped=True
        except:
            pass
        self.Close()
        
        
        
        event.Skip()

    def on_install(self, event):  # wxGlade: update_win.<event_handler>
        #self.play_animation('')
        
        if self.button_install.Label=="Check for Update":
            self.button_install.Enable(False)
            self.thread=update_thread(check=True,install=False)
            self.progress_bar.Hide()            
                
        elif self.button_install.Label=="Install Update":
            #intallhere
            self.button_install.Enable(False)
            self.progress_bar.Show()
            self.thread=update_thread(check=False,install=True)
            
        event.Skip()
    def play_animation(self,msg):
        
        if self.animation_panel.gif:
            self.animation_panel.gif.Stop()
            self.animation_panel.gif.Destroy()
        image="Resources/spinner.gif"
        pos1=self.animation_panel.GetPosition()
        self.animation_panel.gif = wx.animate.GIFAnimationCtrl(self, -1, image,pos=(pos1[0]-20,pos1[1]-40),size=(5,5))
        self.animation_panel.gif.GetPlayer()
        self.animation_panel.gif.Play()
    def stop_animation(self,msg):
        
        self.animation_panel.gif.Stop()
        self.animation_panel.gif.Destroy()
        
    def update(self,msg):
        data = msg.data
        self.label_status.SetForegroundColour(wx.Colour(0, 0, 255))
        self.label_status.SetLabel(str(data))
        self.label_status.Wrap(300)
    def error_report(self,msg):
        data = msg.data
       
        self.label_status.SetForegroundColour(wx.Colour(204, 50, 50))
        self.label_status.SetLabel(str(data))
        self.stop_animation('')
        self.label_status.Wrap(300)
        
    def update_progress_bar(self,msg):
        data = msg.data
        self.progress_bar.SetValue(data)
        pass
    def get_versions(self,msg):
        data = msg.data
        
        self.label_installed_version.SetLabel("Installed Version: "+str(data[0]))
        
        self.label_latest_version.SetLabel("latest Version: "+str(data[1]))
    def is_update(self,available):
        data = available.data
        if data:
            self.label_is_update.SetLabel("Update is available for downlad")
            self.button_install.Enable(True)
            self.button_install.SetLabel("Install Update")
            self.label_status.SetLabel("Update is Available. Click the Install Button below")
            self.label_status.Wrap(300)
            
            
        else:
            self.label_is_update.SetLabel("No updates")
            self.button_install.Enable(False)
            
    def updation_successful(self,msg):
        self.restart()
        
    def restart(self):
        msg="The software will restart in now"
        dlg = wx.MessageDialog(self, msg, '',wx.OK | wx.ICON_INFORMATION)                  
        dlg.ShowModal()
        dlg.Destroy()
        pid=os.fork()
        if pid==0: # new process
            
            subprocess.call("sleep 4\nsmartschool",shell=True)
            
        
        
        self.Destroy()
        self.Parent.Close()
        
        
    def on_close(self,event):
        
        event.Skip()
        
# end of class update_win
if __name__ == "__main__":
    gettext.install("app") # replace with the appropriate catalog name

    app = wx.PySimpleApp(0)
    wx.InitAllImageHandlers()
    update_window = update_win(None, wx.ID_ANY, "")
    app.SetTopWindow(update_window)
    update_window.ShowModal()
    update_window.Destroy()
    app.MainLoop()